1. Срез - структура, которая содержит:
  - указатель на массив
  - длина
  - емкость

2. Срезы копируются при передаче в функцию, как и все в Go.  

3. Можно брать срез который больше длины, но нельзя брать больше емкости. Runtime panic.
Можно брать срез от nil. 

4. Длина производного среза может быть больше, чем у базового, но емкость никогда не будет больше.

5. Go аллоцирует массив среза в стеке, если его размер <= 64КБ, либо при работе escape analysis.
Когда происходит реаллокация, новый массив аллоцируется в куче.

6. Вместо увеличения в 2 раза для < 1024 элементов и в 1,25 раза для >= 1024 элементов. используется более плавная формула для коэффициента роста.
Начинается уменьшаться коэффициент роста после 256 элементов, но медленно.

емкость     коэффициент роста
256         2.0
512         1.63
1024        1.44
2048        1.35
4096        1.30

7. API

7.1 создание слайса: 
  - var a []int - nil slice
  - a := []int{1,2,3} - slice с инициализацией
  - a := make([]int, 3, 6) - slice с инициализацией и указанием длины и cap

7.2 Доступ к данным

b := a[0]

7.3 Итерации
	a := []int{1, 2, 3, 4, 5}

	for i := 0; i < len(a); i++ {
		fmt.Printf("Value: {%d}; Index: {%d}\n", a[i], i)
	}

	// Происходит копирование слайса внутри range
	for idx, value := range a {
		fmt.Printf("Value: {%d}; Index: {%d}\n", value, idx)
	}

7.4 Нарезка

	a := []int{1, 2, 3, 4, 5, 6}

	b := a[2:5] берем от 2 включительно индекса до 5 не включая

7.5 Встроенные функции

	append - добавление элемента в конец среза

	a = append(a, 10)

	copy - Возвращает количество скопированных элементов, которое будет минимумом len(dst) и len(src). 
	Результат не зависит от того, перекрываются ли аргументы.

	var s = make([]int, 3)
	n := copy(s, []int{0, 1, 2, 3}) 
	// n == 3, s == []int{0, 1, 2}

	clear - устанавливает все элементы в пределах текущей длины среза в нулевое значение. Длина и ёмкость среза остаются неизменными.

	s := []int{1, 2, 3, 4, 5}
	clear(s) // [0, 0, 0, 0, 0]
