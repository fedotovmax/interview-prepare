1. В Go 1.24 и более поздних версиях карты реализованы с использованием Swiss Tables,
что значительно повышает производительность и эффективность использования памяти по сравнению с предыдущими версиями.

Группы (Groups): Swiss Tables организованы в виде массива групп.
Каждая группа состоит из 8 слотов (slots), в которых хранятся пары «ключ — значение».

Контрольные байты (control bytes): по 1 байту на слот. Используются для быстрой фильтрации — позволяют понять,
находится ли нужный ключ в группе, прежде чем сравнивать значения напрямую.

Хеш-функция: Хеш-функция играет ключевую роль в работе карт. Она должна быть детерминированной
(один и тот же ключ всегда отображается на один и тот же индекс массива) и равномерно распределять ключи по группам,
чтобы минимизировать коллизии.

Обработка коллизий: Коллизии обрабатываются с помощью битовых масок и быстрых пробингов внутри группы.
Если в группе нет свободного места, происходит переход к следующей доступной группе.

2.

Под капотом эта карта использует хеш-таблицу с небольшим количеством групп, которые содержат эти три элемента.
Однако что произойдет, если добавить 1 миллион элементов? Чтобы избежать таких проблем, карта автоматически увеличивается в размере,
добавляя новые группы при необходимости.

Коэффициент загрузки : Среднее количество элементов в сегментах превышает пороговое значение (в текущей реализации Go это 6.5).
Этот параметр может измениться в будущих версиях, так как является внутренним.

3. Хеш-таблица с открытой адресацией
Швейцарские таблицы — это разновидность хеш-таблицы с открытой адресацией, поэтому давайте кратко рассмотрим,
как работает простая хеш-таблица с открытой адресацией.

В хеш-таблице с открытой адресацией все элементы хранятся в одном резервном массиве. Мы будем называть каждую ячейку в массиве слотом. Слот, к которому принадлежит ключ, определяется хеш-функцией hash(key). Хэш-функция сопоставляет каждый ключ целому числу, при этом один и тот же ключ всегда сопоставляется одному и тому же целому числу, а различные ключи в идеале следуют равномерному случайному распределению целых чисел. Отличительной особенностью хеш-таблиц с открытой адресацией является то, что они разрешают коллизии, сохраняя ключ в другом месте резервного массива. Итак, если слот уже заполнен (коллизия), то используется пробная последовательность для просмотра других слотов, пока не будет найден пустой слот. Давайте рассмотрим пример хэш-таблицы, чтобы понять, как это работает.

0	1	2	3	  4	  5	  6	7	8	9	10 11 12 13 14 15 16
_ _ _ 56  32  21  _ _ _ _ _  78 _  _  _  _  _

Чтобы вставить новый ключ, мы используем хэш-функцию для выбора слота. Поскольку слотов всего 16, нам нужно ограничиться этим диапазоном, поэтому мы будем использовать hash(key) % 16 в качестве целевого слота. Предположим, мы хотим вставить ключ 98, и hash(98) % 16 = 7. Слот 7 пуст, поэтому мы просто вставляем туда 98. С другой стороны, предположим, что мы хотим вставить ключ 25, и hash(25) % 16 = 3. Слот 3 является коллизией, поскольку он уже содержит ключ 56. Поэтому мы не можем вставить его сюда.

Мы используем последовательность зондирования для поиска другого слота. Существует множество известных последовательностей зондирования. Первоначальная и самая простая последовательность зондирования — это линейное зондирование, которое просто проверяет последовательные слоты по порядку.

Таким образом, в примере hash(25) % 16 = 3, поскольку слот 3 занят, мы рассмотрим слот 4, который также занят. То же самое относится и к слоту 5. Наконец, мы доберемся до пустого слота 6, где сохраним ключ 25.

Поиск следует тому же подходу. Поиск ключа 25 начнётся со слота 3, проверит, содержит ли он ключ 25 (его там нет), а затем продолжит линейное зондирование, пока не найдёт ключ 25 в слоте 6.

В этом примере используется резервный массив с 16 слотами. Что произойдёт, если мы вставим более 16 элементов? Если в хэш-таблице закончится место, она увеличится, обычно удваивая размер резервного массива. Все существующие записи будут перевставлены в новый резервный массив.

Хэш-таблицы с открытой адресацией фактически не ждут полного заполнения резервного массива, чтобы начать расти, поскольку по мере заполнения массива средняя длина каждой пробной последовательности увеличивается. В приведенном выше примере с использованием ключа 25 нам необходимо проверить 4 различных слота, чтобы найти пустой. Если бы в массиве был только один пустой слот, в худшем случае длина пробы была бы O(n). То есть, вам может потребоваться просканировать весь массив. Доля используемых слотов называется коэффициентом загрузки, и большинство хэш-таблиц определяют максимальный коэффициент загрузки (обычно 70–90%), при достижении которого они начинают расти, чтобы избежать чрезвычайно длинных пробных последовательностей, характерных для очень полных хэш-таблиц.
