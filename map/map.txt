== ДО GO 1.24

1. Хэш-таблица — это структура данных, ассоциативный массив.
Она позволяет хранить пары «ключ-значение» и выполнять три операции: 
  - поиск значения по ключу, 
  - добавление пары,
  - удаление пары.

2. Коллизия при хеш-функции - случай, когда два разных ключа после выполнения хеш-функции
получают один и тот же индекс

3. Коэф. заполняемости определяется отношением количества хранимых пар «ключ-значение»
к размеру таблицы. Если они достигают пограничного значения - то map расширяется, а индексы
пересчитываются и перераспределяются.

  3.1 Эвакуация запускается не при простом переполнении, а когда коэффициент загрузки (load factor) превышает определенный порог.
  Коэффициент загрузки — это среднее количество элементов на одну "корзину" (bucket) в хеш-таблице. В Go этот порог равен 6.5.
  Когда len(m) / len(buckets) > 6.5, Go решает, что map нужно расширить.
  Выделяется новая память под хеш-таблицу в два раза больше старой, данные перемещаются постепенно. Запись, когда запущен процесс
  эвакуации, осуществляется только в новую таблицу. Чтение и удаление - данные ищутся сначала в новой, если не находятся, то в старой.
  После эвакуации указатель на старую таблицу зануляется.

4. Bucket - ячейка или корзина в массиве хэш-таблицы, которая предназначена для хранения пар ключ-значение, а также метаданных о хеше ключа.
Когда происходит коллизия (два разных ключа попадают в один и тот же бакет), бакет может содержать несколько элементов,
например, в виде связного списка или дерева, чтобы сохранить все данные.

5. Реализация в исходниках

type hmap struct {
  // ...more code
  count       int - количество пар «ключ-значение»
  B           uint 8 - количество бакетов, выраженное через log2
  noverflow   uint 16 - приблизительное количество переполненных бакетов
  hash0       uint 32 - величина для добавления большего разнообразия и случайности в хэш-функцию, позволяет достичь устойчивости к коллизиям.
  buckets     unsafe.Pointer - это указатель на массив бакетов
  oldbuckets  unsafe.Pointer - это также указатель на массив бакетов, из которых происходит эвакуация данных, когда бакетов становится больше
}

6. Элементы в map НЕ хранятся в определенном порядке,
при итерации по карте порядок элементов не гарантируется и может меняться между выполнениями.

7. Тип ключа в карте должен быть сопоставимым, то есть он должен поддерживать операторы равенства (== и !=).
Это включает такие типы, как строки, числа, логические значения, указатели и структуры (если все их поля сравнимы).
Срезы, функции и другие карты не могут использоваться в качестве ключей.

8. Тип значения в карте может быть любым типом Go, включая другие карты или срезы

9. Карты необходимо инициализировать перед использованием, обычно с помощью функции make(),
так как попытка добавить элементы в карту, равную нулю, приведёт к панике во время выполнения.

10. API

  Создание: make(map[KeyType]ValueType)
  Вставка/обновление: m[key] = value
  Извлечение: value = m[key] (с необязательным вторым возвращаемым значением (bool) для проверки существования ключа: value, ok := m[key])
  Удаление: delete(m, key)
  Длина: len(m)

11. Работа с многопоточностью

  Потокобезопасность работы с встроенными мапами в Go гарантируется только при выполнении следующих условий:

  Чтение без записи на том же ключе. Если несколько горутин одновременно читают из мапы,
  и ни одна из них не пытается записать или удалить элемент, то это безопасно.

  Доступ только из одной горутины. Если мапа используется исключительно одной горутиной и никогда не передается
  или не разделяется между другими, то это безопасно.

  Использование sync.Map. Специализированный тип sync.Map из стандартной библиотеки Go
  обеспечивает потокобезопасность для одновременных операций чтения и записи множеством горутин без необходимости
  явного использования мутексов. sync.Map оптимизирован для случаев, когда ключи чаще читаются, чем пишутся.

  Важно помнить, что одновременная запись или удаление в обычной встроенной мапе из разных горутин
  приводит к состоянию гонки (data race), что является неопределенным поведением и может привести к панике или некорректным результатам.

  Для обеспечения потокобезопасности при одновременной записи и чтении из встроенной мапы
  следует использовать примитивы синхронизации, такие как sync.Mutex или sync.RWMutex.

== ПОСЛЕ GO 1.24