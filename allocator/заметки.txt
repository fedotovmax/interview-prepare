1.
Стек памяти в Go — это область памяти для динамического выделения данных, где располагаются локальные переменные,
аргументы функций и временные данные, которые автоматически удаляются после завершения функции. В отличие от кучи,
стек используется для быстрого выделения и освобождения памяти, при этом в Go стек изначально выделяется для горутин, 
а при его переполнении создается новый, более крупный стек, который может быть как в стековой области, так и в куче. 

Основные характеристики стека памяти в Go: 
  - Статическое распределение, память выделяется и освобождается во время выполнения программы.

  - LIFO (Last-In, First-Out) последний добавленный элемент (например, вызов функции) является первым, который извлекается при завершении.

  - Локальные переменные и аргументы, в стеке хранятся переменные, которые определены внутри функции, и аргументы, передаваемые ей.

  - Автоматическое освобождение, после завершения выполнения функции вся память, выделенная для ее локальных данных, автоматически освобождается.

Стек vs. Куча:
  - Скорость, стек быстрее и проще в управлении, чем куча, так как выделение и освобождение памяти выполняется очень быстро. 

  - Назначение, стек подходит для временных данных и локальных переменных, а куча используется для данных, которые должны сохраняться дольше,
    например, для объектов, созданных с помощью оператора new() или для больших структур данных.

2.

В Golang куча (heap) — это область памяти для динамически выделяемых данных, которые могут существовать дольше, чем одна функция,
и управляются автоматически сборщиком мусора (GC). В отличие от стека, куча используется для больших объемов данных или когда время жизни переменной не привязано к вызову функции.
Память в куче выделяется для объектов, созданных с помощью оператора new или для глобальных переменных. 

Ключевые аспекты:

Динамическое выделение:
  - Объекты небольшого размера и короткого времени жизни, где компилятор не может доказать, что их время жизни ограничено пределами функции или стека,
    или которые выделяются с помощью new или взятия адреса (&), обычно размещаются в куче.

  - Сборщик мусора (GC)

  - Escape Analysis: Компилятор Golang проводит анализ (escape analysis), чтобы определить, куда указывает переменная или значение — на стек или на кучу.
    Если переменная или структурное поле может быть доступно после возврата из текущей горутины, оно, скорее всего, будет выделено в куче.
    В противном случае, оно может быть выделено на стеке.

  - Разделение на арены (Arenas): Куча в Go может быть разделена на несколько арены, что помогает сборщику мусора работать более эффективно,
    особенно на многопроцессорных системах.

  - Использование mmap: Golang использует системный вызов mmap (Memory Map) для выделения больших блоков виртуальной памяти для кучи.

  - Непрерывность: В отличие от некоторых языков, Go не гарантирует физическую непрерывность объектов в куче. Память может быть фрагментирована.

  - Отсутствие ручного управления памятью: Разработчику не нужно явно выделять или освобождать память в куче. GC делает это автоматически.

3. Аллокатор

Объекты в стеке:
  - Когда вы объявляете локальную переменную в функции (например, var x int), она размещается в стеке.
Передача указателя:
  - Если вы передаете указатель на локальную переменную (&x) в другую функцию, в стеке вызываемой функции создается копия этого указателя.
    Сам объект x при этом остается в стеке исходной функции.
Возврат указателя:
  - Когда вы возвращаете указатель на локальную переменную (return &x), компилятор Go распознает этот паттерн и автоматически перемещает объект x
    из стека в кучу. Это сделано для того, чтобы объект остался доступным и после завершения работы вызываемой функции,
    а сборщик мусора позаботится об управлении его памятью в дальнейшем.
Объекты в куче (с использованием new или make):
  - Если вы хотите, чтобы объект изначально находился в куче и был долгоживущим, используйте new или make. Например, ptr := new(MyStruct)
    или ptr := make([]int, 5). В этом случае указатель ptr будет содержать адрес объекта из кучи.

4. Сборщик мусора

  - Go использует concurrent, триколорный, Mark-and-Sweep сборщик мусора. Он работает одновременно с выполнением программы, минимизируя паузы.
  - Mark (Пометка): GC обходит достижимые объекты из корневых указателей (локальные переменные на стеках, глобальные переменные) и помечает их как "живые".
  - Sweep (Зачистка): GC проходит по всей доступной куче и освобождает память, занятую объектами, которые не были помечены как "живые".
  - Concurrent: GC работает в отдельных горутинах, уменьшая задержки в работе основной программы.

Как идёт процесс

  - Инициализация (все белые)
    В начале все объекты в куче помечаются белыми.

  - Старт от корней (root set)
    Корни: глобальные переменные, стеки горутин, регистры процессора.
    Эти объекты становятся серыми, т.к. мы знаем, что они живые, но их надо проверить глубже.

  - Обработка серых объектов (mark phase)
    Берём серый объект.
    Все ссылки внутри него на другие объекты проверяются:
      Если объект был белым → он становится серым (нашли живой объект).
      Если он уже серый/чёрный → ничего не меняем.
    После того как все ссылки просканированы, сам объект окрашивается в чёрный.

  - Завершение маркировки
    Когда серых объектов больше нет → процесс остановлен.
    Всё, что осталось белым → не достижимо, можно удалить.

Гарантии корректности

Go использует write barrier (барьер записи), чтобы не потерять ссылки, которые могут появиться во время работы GC.

Пример:

  - Пока GC сканирует объект A, в это время программа (mutator) может записать ссылку на новый объект B.
  - Чтобы GC не "пропустил" его, запись в память проходит через "барьер", который гарантирует:
      Если ссылка указывает на белый объект → он немедленно окрашивается в серый.

Это позволяет GC работать конкурентно (одновременно с кодом программы) и не потерять живые данные.